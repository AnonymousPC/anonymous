1. 关于取出一个view但是是引用的情况：
    首先，考察 const array_view& array::operator[](int, int, int) const;
    现在这个array是const的，所以const不可能新开辟空间去生成一个引用，否则你需要一个开销极大且mutable的同步队列。
    注意，所有operator[]用尽后，返回的单个type&一定是引用。
    其次，考察一个mfcc滤波器，它输出约40个数，并把2-11这几个数作为结果输出。
    auto mfcc(const array_type auto&) { ...; return array[2,11]; }
    如果是view但引用，则原数组释放不掉。

2. 关于用view共管本体array的情况：
    同样，const array_view& array::operator[](int, int, int) const;
    const时改变内部引用计数是不推荐的。

3. 所以，内存问题交给用户自己解决，用户自己应该管理好view的生存期。

4. TODO: matrix[1]改为一个view，非引用。